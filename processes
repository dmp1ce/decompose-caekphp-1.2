DECOMPOSE_PROCESSES=( 'env' 'explore' 'dc' 'build' 'up' 'start_nginx_proxy'
  'stop_nginx_proxy' 'increment-tag'
  'generate_self_signed_certs' 'import_db' 'explore_db' 'import_uploads'
  'import_cache' 'project-root' 'backup_config'
  'update-production-server-to-latest' )

_decompose-process-env() {
  echo "$PROJECT_ENVIRONMENT"
  echo "PRODUCTION: $PRODUCTION"
  echo "DEVELOPMENT: $DEVELOPMENT"
}
_decompose-process-env_help() {
  echo "  Show environment setting"
}

_decompose-process-explore() {
  echo "Entering PHP container clone..."
  echo "docker-compose -f $dc_config_file run --rm php /bin/bash"
}
_decompose-process-explore_help() {
  echo "  Explore!"
}

_decompose-process-explore_db() {
  # Get the name of the database container
  db_container_name=$(docker-compose ps -q db)

  # Enter mysql
  docker exec -it $db_container_name bash -c "export TERM=dumb; mysql -u app_user -ppassword -D app"
}
_decompose-process-explore_db_help() {
  echo "  Explore database"
}

_decompose-process-dc() {
  echo 'docker-compose -f $dc_config_file "$@"'
}
_decompose-process-dc_help() {
  echo "  Run docker compose in the current environment ($PROJECT_ENVIRONMENT)"
}

_decompose-process-build() {
  # Build all the decompose templates
  decompose-process-templates 

  # Get current base version
  local project_root; _decompose-project-root project_root
  local git_base_revision="`git describe --tags --match=v* --always --dirty 2>&1`"
  local git_base_status="`git status -unormal 2>&1`"

  # Set current base version
  echo -e "$PROJECT_ENVIRONMENT\n$git_base_revision" > \
    "$project_root"/"$PROJECT_VERSION_FILE"

  docker-compose build
}
_decompose-process-build_help() {
  echo "  Build the project"
}

_decompose-process-up() {
  docker-compose up -d
}
_decompose-process-up_help() {
  echo "  Start project locally"
}

_decompose-process-increment-tag() {
  # Verify that there are no version tags on at HEAD
  # so we don't create more tags than we need
  local head_version_tag=$(git describe --tags --candidates=0 --match=v* 2> /dev/null)

  if [ $head_version_tag ]; then
    echo "The version '$head_version_tag' already exists for HEAD"
    return 1
  fi

  # Increment tag
  local newtag=$(git describe --abbrev=0 --tags --match=v* | awk -F. -v OFS=. 'NF==1{print ++$NF}; NF>1{if(length($NF+1)>length($NF))$(NF-1)++; $NF=sprintf("%0*d", length($NF), ($NF+1)%(10^length($NF))); print}')

  git tag "$newtag"
}
_decompose-process-increment-tag_help() {
  echo "  Increments the last tag and creates a new tag in git"
}

__decompose-process-update-production-repo() {
    __decompose-process-ssh-command "git pull --recurse-submodules"
}

# Parameters
#   $1: command
__decompose-process-ssh-command() {
  ssh $PROJECT_PRODUCTION_SERVER_USER@$PROJECT_PRODUCTION_SERVER_IP \
    "cd $PROJECT_PRODUCTION_SERVER_BASE_PATH && $1"
}

_decompose-process-update-production-server-to-latest() {
  # Test that user can update production git repository successfully
  echo "Testing user access to prodcution server..."
  __decompose-process-update-production-repo || local fetch_failed=1
  if [ $fetch_failed ]; then
    echo "Access test failed!"
    echo "Check your SSH access to the production server and source control."
    exit 1
  else
    echo "Access test passed."
  fi

  # increment the last tag
  echo "Incrementing version tag..."
  _decompose-process-increment-tag

  # push production to source control server
  echo "Pushing local changes to source control server..."
  git push && git push --tags

  # update decompose environment on server
  echo "Update decompose evironment on production server..."
  __decompose-process-ssh-command "decompose --update"

  # run ssh command to update server
  echo "Rebuilding production environment..."
  __decompose-process-ssh-command "decompose build && decompose up"

  echo "Done."
}
_decompose-process-update-production-server-to-latest_help() {
  echo "  Update production to the latest code with the folloing steps:"
  echo "  -------------------------------------------------------------"
  echo "  1. Test connection to server"
  echo "  2. Create new tag, incremented from the last tag"
  echo "  3. Push latest code and tags"
  echo "  4. Update code on production site"
  echo "  5. Rebuild/recreate production containers"
}

_decompose-process-start_nginx_proxy() {
  local nginx_proxy_id=$(docker ps --format "{{.ID}} {{.Image}}" | grep "jwilder/nginx-proxy" | cut -d " " -f1)
  if [ -n "$nginx_proxy_id" ]; then
    echo "nginx-proxy ($nginx_proxy_id) is already running"
    echo "Try stoping nginx-proxy first with 'decompose stop_nginx_proxy'"
    return 0
  fi
  # TODO: Also search for 'nginx-proxy' label
  docker run --label "nginx_proxy" -d -p 80:80 -p 443:443 --restart="always" -e DEFAULT_HOST="$PROJECT_NGINX_DEFAULT_HOST" -v /var/run/docker.sock:/tmp/docker.sock:ro jwilder/nginx-proxy
}
_decompose-process-start_nginx_proxy_help() {
  echo "  Start nginx-proxy which can host multiple sites"
}

_decompose-process-stop_nginx_proxy() {
  local nginx_proxy_id=$(docker ps --format "{{.ID}} {{.Image}}" | grep "jwilder/nginx-proxy" | cut -d " " -f1)
  if [ -n "$nginx_proxy_id" ]; then
    echo "Closing currently running proxy: $nginx_proxy_id"
    docker stop "$nginx_proxy_id"
  fi
  # TODO: Also search for 'nginx-proxy' label
}
_decompose-process-stop_nginx_proxy_help() {
  echo "  Stop nginx-proxy"
}

_decompose-process-generate_self_signed_certs() {
  local project_root; _decompose-project-root project_root
  mkdir $project_root/certs
  openssl req -nodes -x509 -newkey rsa:4096 -keyout $project_root/certs/server.key -out $project_root/certs/server.crt -days 356
}
_decompose-process-generate_self_signed_certs_help() {
  echo "  Generate self signed tls certifications"
}

_decompose-process-import_db() {
  # Verify the the first parameter is a file
  local sql_file=$1
  if [ ! -e "$sql_file" ]; then
    echo "File '$sql_file' does not exist"
    exit 1
  fi

  # Get the name of the database container
  db_container_id=$(docker-compose ps -q db)

  # Copy file to container /tmp
  docker cp $sql_file $db_container_id:/tmp

  # Import file
  docker exec $db_container_id bash -c "export TERM=dumb; mysql -u app_user -ppassword -D app < /tmp/$sql_file"

  # Delete /tmp file
  docker exec $db_container_id rm /tmp/$sql_file
}
_decompose-process-import_db_help() {
  echo "  Import DB passed in as a parameter 1"
}

_decompose-process-import_uploads() {
  # Verify the the first parameter is a file
  local directory=$1
  if [ ! -d "$directory" ]; then
    echo "Directory '$directory' does not exist"
    exit 1
  fi

  # Get the name of the database container
  php_container_name=$(docker-compose ps -q php)

  # Copy directory to container
  docker cp $directory/. $php_container_name:/srv/http/source/app/webroot/img/uploads
}
_decompose-process-import_uploads_help() {
  echo "  Copies 'uploads' directory to the php container"
}

_decompose-process-import_cache() {
  # Verify the the first parameter is a file
  local directory=$1
  if [ ! -d "$directory" ]; then
    echo "Directory '$directory' does not exist"
    exit 1
  fi

  # Get the name of the database container
  php_container_name=$(docker-compose ps -q php)

  # Copy directory to container /tmp
  docker cp $directory/. $php_container_name:/srv/http/source/app/webroot/img/cache
}
_decompose-process-import_cache_help() {
  echo "  Copies 'cache' directory to the php container"
}

_decompose-process-project-root() {
  local project_root; _decompose-project-root project_root; echo $project_root
}
_decompose-process-project-root_help() {
  echo "  Print project root directory"
}

_decompose-process-backup_config() {
  echo "Backing up config..."
  local project_root; _decompose-project-root project_root

  local string_time=$(date +%s)
  local config_name=$PROJECT_NGINX_VIRTUAL_HOST_PROD
  local asc_files=$(cd "$project_root";\
    echo ./containers/backup/.duply/site_data/*.asc)

  mkdir -p "$project_root"/backup_config
  tar -C "$project_root" \
    -cvzf "$project_root"/backup_config/$config_name-config-$string_time".tar.gz" \
    --exclude="*.git" \
    ./.decompose \
    ./containers/backup/.ssh \
    $asc_files
}
_decompose-process-backup_config_help() {
  local project_root; _decompose-project-root project_root
  echo "  Creates backup file of the current configuration for safe keeping"
  echo "  File is copied to '$project_root/backup_config' directory"
}


# vim:syntax=sh
